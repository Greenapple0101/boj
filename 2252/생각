줄세우기 문제
사실 이건 위상정렬 문제다
난 위상정렬 공부를 안해서 하고 와야한다
9시 44분

대충 10분동안 짠 코드

#include <vector>
#include <iostream>
#include <queue>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  int N, M;
  cin >> N >> M;
  vector<int> adj[32001];
  int front_cnt[32001];
  queue<int> q;
  vector<int> s;
  for(int i = 0; i < M; i++) {
    int A, B;
    cin >> A >> B;
    adj[A].push_back(B);
    front_cnt[B]++;
  }
  for(int i=0;i<N;i++){
    if(front_cnt[i]==0){
      q.push(i);
    }
  }
  while(!q.empty()){
    int curr=q.front();
    q.pop();
    for(int val:adj[curr]){
      q.push(val);
      front_cnt[curr]--;
    }
    if(front_cnt[curr]==0){
      s.push_back(curr);
    }
  }
  for(int i=0;i<s.size();i++){
    cout<<s[i]<<" ";
  }
  return 0;
}

이제 뭘 고쳐야 할까

#include <vector>
#include <iostream>
#include <queue>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  int N, M;
  cin >> N >> M;
  vector<int> adj[32001];
  int front_cnt[32001]={0,};
  queue<int> q;
  for(int i = 0; i < M; i++) {
    int A, B;
    cin >> A >> B;
    adj[A].push_back(B);
    front_cnt[B]++;
  }
  for(int i=1;i<=N;i++){
    if(front_cnt[i]==0){
      q.push(i);
    }
  }
  while(!q.empty()){
    int curr=q.front();
    cout<<curr<<" ";
    q.pop();
    for(int val:adj[curr]){
      front_cnt[val]--;
      if(front_cnt[val]==0){
        q.push(val);
      }
    }
  }
  return 0;
}

일단 두가지만 고치면 됐음
1. 진입차수 내리는 건 이미 0인애가 아님. 0인 애들의 인접행렬에 속한 애들
2. 그리고 벡터 따로 만들지 말고 큐에 넣고 그대로 출력
3. 초기화 잊지 말고
4. front_cnt할때 i 1부터 넣는거 꼼꼼하게 이건 횟수가 아니라 실제 인덱스니까
끝! 잘풀었다. 다음 문제 풀러 ㄱ
