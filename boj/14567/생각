위상 정렬 문제 같다
#include <iostream>
#include <queue>
#include <vector>
#include <utility>
using namespace std;
vector<pair<int,int>> pair1;
int main() {
    ios::sync_with_stdio(false);
    int N, M;
    cin >> N >> M;
    vector<vector<int>> pre(N+1);
    int cnt[1001]={0, };
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        pre[A].push_back(B);
        cnt[B]++;
    }
    queue<int> q;
    for (int i=1;i<N+1;i++) {
        if (cnt[i]==0) {
            q.push(i);
            pair1.push_back({i,1});
        }
    }

    int c=1;
    while (!q.empty()) {
        int curr=q.front();
        q.pop();
        if (pre[curr].size())
            c++;
        for (int val:pre[curr]) {
            cnt[val]--;
            if (cnt[val]==0) {
                q.push(val);
                pair1.push_back({val,c});
            }
        }
    }
    sort(pair1.begin(),pair1.end());
    for (int i=0;i<pair1.size();i++) {
        cout<<pair1[i].second<<" ";
    }
    return 0;
}

여기까진 했는데....
자꾸 학기수를 세는게 아니라
cnt를 잘못하는 거 같아서

아예 그냥 진입차수를 세고 그 순서대로 해야하나
내 앞에 몇개 있는지 그걸 해야하나 하고

#include <iostream>
#include <queue>
#include <vector>
#include <utility>
using namespace std;
vector<pair<int,int>> pair1;
int main() {
    ios::sync_with_stdio(false);
    int N, M;
    cin >> N >> M;
    vector<vector<int>> pre(N+1);
    int cnt[1001]={0, };
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        pre[A].push_back(B);
        cnt[B]++;
    }
    queue<int> q;
    for (int i=1;i<N+1;i++) {
        q.push(i);
        pair1.push_back({i,cnt[i]});
    }

    sort(pair1.begin(),pair1.end());
    for (int i=0;i<pair1.size();i++) {
        cout<<pair1[i].second<<" ";
    }
    return 0;
}

단순히 이렇게만 하니까 3앞에 2가 올경우에
2의 진입차수를 고려해야했었음

queue<int> q;
    int maax=-1e9;
    for (int i=1;i<N+1;i++) {
        for (int val:pre[i]) {
            if (cnt[val])>maax){
                maax=cnt[val];}
        }
        pair1.push_back({i,maax+1});
    }
그래서 이렇게 하면 또 이상해!

어떻게 풀어!
그나마 가장 답에 가까운 상태에서 다시 접근해야하나...
답지 진짜 보기 싫은데
큐에서 과목 하나 꺼낼때 마다 그 과목에 다음 과목이 있기만하면 학기가 전체적으로 올라가버림
내 학기는 나를 가리키는 선수과목들의 학기 중 최대값이어야함.... 그래 이렇게 풀었다고 난
dp써야함. ㅋㅋ

semester[val]=max(semester[val],semester[curr]+1);

이줄 하나로 모든 게 해결됨.
지금의 학기수는... 이전학기수에 1을 더한것. 아니면
예를들어
실제로 2학기까지 들을수 있을거 같지만
그니까 val이 속한 인접리스트가 한두개가 아니면 저렇게 계속 갱신이 되는거네
그럼 계속 갱신되나 ... 위상정렬에서는 일단 그럼.
dp 어렵당