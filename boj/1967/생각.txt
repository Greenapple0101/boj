import sys
input=sys.stdin.readline
N=int(input())
adj=[[] for _ in range (N+1)]
for _ in range(1,N):
  p,c,g=list(map(int,input().split()))
  adj[p].append((c,g))

max_gram=-1e9
gram=0
lst=[]
def dfs(n,gram):
  if(adj[n]==[]):
    lst.append(gram)
  for val in adj[n]:
    dfs(val[0],gram+val[1])

dfs(adj[1][0][0],0)
ans=sorted(lst)
a1=max(ans)
dfs(adj[1][1][0],0)
ans=sorted(lst)
a2=max(ans)
print(a1,a2,adj[1][0][1],adj[1][1][1])
star=a1+a2+adj[1][0][1]+adj[1][1][1]
print(star)

처음에는 당연히 루트노드를 기준으로 양끝일거라 생각함
근데 아니었음
같은 할머니 가진친구들끼리 연결해도 트리의 지름이 나올수가 있었음

1. 코드를 if문으로 복잡하게 짠다 (같은 할머니, 다른할머니 경우 나눠서)
2. 그냥 노드 두개 입력하면 거리 구해주는 코드를 짜고 인자로 리프노드를 넣는다

1은 너무 복잡해서 안됨 트리의 깊이가 깊어질수록 경우의수가 매우 많아짐
2번으로 가야함
어차피 리프노드들만 넣을거니까 그걸 상정해서 하자

import sys
input=sys.stdin.readline
N=int(input())
adj=[[] for _ in range (N+1)]
parent=[]*(N+1)
for _ in range(1,N):
  p,c,g=list(map(int,input().split()))
  adj[p].append((c,g))
  adj[c].append((p,g))

max_gram=-1e9
gram=0
lst=[]
idx=0
visited=[0]*(N+1)
def dfs(n,gram):
  global max_gram,idx
  visited[n]=1
  if(len(adj[n])==1):
    if(gram>max_gram):
      max_gram=gram
      idx=n

  for val in adj[n]:
    if(visited[val[0]]):continue
    dfs(val[0],gram+val[1])

dfs(1,0)
visited=[0]*(N+1)
max_gram=0
dfs(idx,0)
print(max_gram)

dfs 두번쓰는
로직 자체는 맞는데 이제 런타임 에러가 나네 ㅋㅋㅋ
근데 신기하다....
부모랑 자식 다 넣는거....
그러고 visited 처리하면 감쪽같네

왜 런타임에러가 날까
1. 백트래킹을 안했어요?
   근데 백트래킹 어떻게 해야할지를 모르겠다
   할 구석이 없는데
2. dfs를 해도 런타임 에러가 나면 어쩝니까
   30% 정도 가다가 지혼자 고꾸라지네
3. 아 sys.setrecursionlimit(10**6).. 시간낭비했네