cmath 불러서 각각 거리 구해서 dist에 넣고
크루스칼 하면 되겠다
double 표현형...

hypot이 거리계산에 직빵.
hypot(거리,거리) 하면됨
sqrt()랑 pow() 사용

sqrt(pow(거리,2),pow(거리,2)); 이렇게 해도 됨

#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
struct Edge {
    int x;
    int y;
    double dist;
    bool operator< (const Edge& other) const{
        return dist<other.dist;
    }
};

void unite(int a, int b) {
    a=rot(a);
    b=rot(b);
    if (a!=b) {
        a=rootty[b];
    }
}

int rootty[101]
int rot(int x) {
    if (rootty[x]==x) return x;
    return rootty[x]=rootty[rot(x)];
}

int main() {
    ios::sync_with_stdio(false);

    int n;
    cin >> n;

    vector<pair<double, double>> stars;
    for (int i = 0; i < n; ++i) {
        double x, y;
        cin >> x >> y;
        stars.push_back({x, y});
    }
    vector<Edge> edges;

    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++) {
            double dist=hypot(stars[i].first-stars[j].first,stars[i].second-stars[j].second);
            edges.push_back({i,j,dist});
            V++;
        }

    sort(edges.begin(),edges.end());
    double ans=0;
    int cnt=0;
    for (auto& val:edges) {
        if (rot(val.x)!=rot(val.y)) {
            unite(val.x,val.y);
            ans+=val.dist;
            if (++cnt==V-1) break;
        }
    }
    cout<<ans;
    return 0;
}


위에 처럼 풀고 나온 오류 세개

1. Union-Find 로직의 오류

unite 함수: 현재 a = rootty[b];라고 되어 있는데,
이건 a의 부모를 b로 바꾸는 게 아니라 b의 부모 값을 a에 대입하는 것임.
정반대로 되어 있음
a의 부모를 b로 바꿔야함. rootty[a]=b 이렇게 되어야함. 솔직히 모르겠음. 그냥 외우자.

rot 함수 (Path Compression): return rootty[x] = rot(rootty[x]);가
되어야 경로 압축이 제대로 일어납니다. 지금 코드는 무한 루프에 빠질 위험이 있음.

2. 간선 선택 종료 조건 (cnt == V-1)
V를 edges.size()로 잡으셨는데, MST에서 필요한 간선의 개수는 **(정점의 개수 - 1)**
개입니다. 즉, n - 1개가 되어야 합함.

3. 초기화 누락
rootty 배열은 처음에 자기 자신을 가리키도록(rootty[i] = i) 초기화해야 합니다.